<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Accueil</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <link href="/leaflet/leaflet.css" rel="stylesheet" />
    <style>
      #map {
        height: 500px;
      }
      #error-message {
        color: red;
        font-weight: bold;
        margin-top: 20px;
      }
      #video-chat {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        z-index: 1000;
      }
      #video-chat video {
        width: 300px;
        height: 200px;
      }
    </style>
  </head>
  <body class="bg-gray-100 text-gray-800">
    <header class="bg-white shadow">
      <div class="container mx-auto px-4 py-6">
        <h1 class="text-3xl font-bold text-center">
          Bienvenue sur notre Application
        </h1>
      </div>
    </header>
    <main class="container mx-auto px-4 py-8">
      <section class="bg-white p-6 rounded-lg shadow-lg">
        <h2 class="text-2xl font-semibold mb-4">Fonctionnalités</h2>
        <ul class="list-disc pl-5 space-y-2">
          <li>Partage de position en temps réel</li>
          <li>Visioconférence avec WebRTC</li>
          <li>Utilisation de l'accéléromètre</li>
        </ul>
      </section>
      <section class="bg-white p-6 rounded-lg shadow-lg mt-8">
        <h2 class="text-2xl font-semibold mb-4">Carte des Utilisateurs</h2>
        <div id="user-form" class="flex justify-center mb-4">
          <input
            type="text"
            id="username"
            placeholder="Entrez votre nom"
            class="p-2 border rounded mr-2"
          />
          <button
            onclick="initializeUser()"
            class="bg-blue-500 text-white px-4 py-2 rounded"
          >
            Commencer
          </button>
        </div>
        <div id="map" class="mb-4"></div>
        <div id="error-message"></div>
        <div id="user-list">
          <h3 class="text-xl font-semibold mb-2">Liste des Utilisateurs</h3>
          <ul id="user-list-ul" class="space-y-2"></ul>
        </div>
      </section>
    </main>
    <footer class="bg-white shadow mt-8">
      <div class="container mx-auto px-4 py-6 text-center">
        <p>&copy; 2024 Notre Application. Tous droits réservés.</p>
      </div>
    </footer>

    <div id="video-chat" class="bg-white p-6 rounded-lg shadow-lg">
      <h3 class="text-xl font-semibold mb-4">Visioconférence</h3>
      <video id="local-video" playsinline autoplay class="w-full mb-4"></video>
      <video id="remote-video" playsinline autoplay class="w-full"></video>
      <button
        onclick="endVideoCall()"
        class="bg-red-500 text-white px-4 py-2 rounded mt-4"
      >
        Terminer l'appel
      </button>
    </div>

    <script src="/leaflet/leaflet.js"></script>
    <script>
      let userId = null;
      let username = null;
      let ws = null;
      let peerConnection = null;
      let iceCandidatesQueue = [];

      const configuration = {
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      };

      L.Icon.Default.imagePath = "https://unpkg.com/leaflet@1.7.1/dist/images/";

      const map = L.map("map").setView([51.505, -0.09], 13);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
      }).addTo(map);

      const markers = {};

      const updateUserPositions = (users) => {
        if (!Array.isArray(users)) {
          console.error(
            "La réponse de l'API n'est pas un tableau d'utilisateurs:",
            users
          );
          return;
        }
        const userList = document.getElementById("user-list-ul");
        userList.innerHTML = ""; // Clear the list
        users.forEach((user) => {
          if (markers[user.id]) {
            markers[user.id].setLatLng([user.position.lat, user.position.lng]);
          } else {
            markers[user.id] = L.marker([user.position.lat, user.position.lng])
              .addTo(map)
              .bindPopup(user.name)
              .openPopup();
          }
          // Add user to the list
          const li = document.createElement("li");
          li.className =
            "flex justify-between items-center p-2 bg-gray-100 rounded shadow";
          li.innerHTML = `<span>${user.name}</span> <button onclick="inviteToVideoCall('${user.id}')" class="bg-green-500 text-white px-2 py-1 rounded">Visio</button>`;
          userList.appendChild(li);
        });
      };

      const fetchUserPositions = async () => {
        try {
          const response = await fetch("/api/users");
          if (!response.ok) {
            throw new Error(
              "Erreur lors de la récupération des utilisateurs: " +
                response.statusText
            );
          }
          const text = await response.text(); // Lire la réponse en tant que texte
          const users = JSON.parse(text); // Convertir le texte en JSON

          updateUserPositions(users);
        } catch (error) {
          console.error(
            "Erreur lors de la récupération des utilisateurs:",
            error
          );
        }
      };

      const sendUserPosition = (position) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          const data = {
            id: userId,
            name: username,
            position: {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
            },
            type: "update",
          };
          ws.send(JSON.stringify(data));
        } else {
          console.warn("WebSocket is not open. Cannot send position.");
        }
      };

      const updateUserPosition = (position) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          const data = {
            id: userId,
            name: username,
            position: {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
            },
            type: "update",
          };
          ws.send(JSON.stringify(data));

          // Mettre à jour le marqueur de l'utilisateur sur la carte
          if (markers[userId]) {
            markers[userId].setLatLng([
              position.coords.latitude,
              position.coords.longitude,
            ]);
          } else {
            markers[userId] = L.marker([
              position.coords.latitude,
              position.coords.longitude,
            ])
              .addTo(map)
              .bindPopup(username)
              .openPopup();
          }

          // Centrer la carte sur la position de l'utilisateur
          map.setView(
            [position.coords.latitude, position.coords.longitude],
            map.getZoom()
          );
        } else {
          console.warn("WebSocket is not open. Cannot update position.");
        }
      };

      const successCallback = (position) => {
        sendUserPosition(position);
        map.setView([position.coords.latitude, position.coords.longitude], 13);

        // Ajouter le marqueur initial de l'utilisateur
        if (!markers[userId]) {
          markers[userId] = L.marker([
            position.coords.latitude,
            position.coords.longitude,
          ])
            .addTo(map)
            .bindPopup(username)
            .openPopup();
        }

        // Mettre à jour la position de l'utilisateur toutes les 10 secondes
        setInterval(() => {
          navigator.geolocation.getCurrentPosition(
            updateUserPosition,
            errorCallback
          );
        }, 10000);
      };

      const errorCallback = (error) => {
        const errorMessageElement = document.getElementById("error-message");
        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorMessageElement.textContent =
              "L'utilisateur a refusé la demande de géolocalisation.";
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessageElement.textContent =
              "Les informations de localisation sont indisponibles.";
            break;
          case error.TIMEOUT:
            errorMessageElement.textContent =
              "La demande de localisation a expiré.";
            break;
          case error.UNKNOWN_ERROR:
            errorMessageElement.textContent =
              "Une erreur inconnue s'est produite.";
            break;
        }
        console.error(error);
      };

      const initializeUser = async () => {
        username = document.getElementById("username").value.trim();
        if (!username) {
          alert("Veuillez entrer un nom");
          return;
        }
        userId = "user-" + Date.now(); // Générer un ID unique pour l'utilisateur
        document.getElementById("user-form").style.display = "none";

        try {
          // Vérifiez et demandez la permission de géolocalisation
          const geoPermission = await navigator.permissions.query({
            name: "geolocation",
          });
          if (
            geoPermission.state === "granted" ||
            geoPermission.state === "prompt"
          ) {
            navigator.geolocation.getCurrentPosition(
              successCallback,
              errorCallback
            );
          } else {
            alert("Géolocalisation refusée");
          }

          // Vérifiez et demandez la permission pour la caméra et le microphone
        } catch (error) {
          console.error("Erreur d'accès aux périphériques:", error);
          alert("Erreur d'accès aux périphériques : " + error.message);
        }

        // Initialise WebSocket connection
        ws = new WebSocket("wss://gwilym.is-a.dev"); // Utilisez l'URL de votre serveur sécurisé
        ws.onopen = () => {
          console.log("WebSocket connected");
        };
        ws.onmessage = async (event) => {
          const message = JSON.parse(event.data);
          console.log("WebSocket message received:", message); // Ajout du log pour chaque message reçu

          switch (message.type) {
            case "offer":
              await handleVideoOffer(message.offer, message.from);
              break;
            case "answer":
              await handleVideoAnswer(message.answer);
              break;
            case "candidate":
              await handleNewICECandidate(message.candidate);
              break;
            case "invite":
              const accept = confirm(
                `${message.from} vous invite à une visioconférence. Acceptez-vous ?`
              );
              if (accept) {
                startVideoCall(message.from);
              }
              break;
            case "update":
              break;
            default:
              console.warn("Unknown message type:", message.type);
          }
        };
        ws.onclose = () => {
          console.log("WebSocket disconnected");
        };
        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
        };

        window.addEventListener("beforeunload", () => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            const data = {
              id: userId,
              type: "disconnect",
            };
            ws.send(JSON.stringify(data));
          }
        });
      };

      const startVideoCall = async (id) => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          document.getElementById("local-video").srcObject = stream;
          document.getElementById("video-chat").style.display = "block";

          peerConnection = new RTCPeerConnection(configuration);

          stream
            .getTracks()
            .forEach((track) => peerConnection.addTrack(track, stream));

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              console.log("Sending ICE candidate:", event.candidate);
              ws.send(
                JSON.stringify({
                  type: "candidate",
                  candidate: event.candidate,
                  to: id,
                })
              );
            }
          };

          peerConnection.ontrack = (event) => {
            const remoteStream = event.streams[0];
            console.log("Remote Stream:", remoteStream);

            const remoteVideo = document.getElementById("remote-video");
            if (remoteVideo) {
              remoteVideo.srcObject = remoteStream;
              console.log("Remote video element found and stream assigned.");
            } else {
              console.error("Remote video element not found.");
            }
          };

          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);
          console.log("Local Description Set with Offer:", offer);

          ws.send(JSON.stringify({ type: "offer", offer: offer, to: id }));
        } catch (error) {
          console.error("Error starting video call:", error);
          alert(
            "Erreur lors de l'accès aux périphériques médias : " + error.message
          );
        }
      };

      const handleVideoOffer = async (offer, from) => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          document.getElementById("local-video").srcObject = stream;
          document.getElementById("video-chat").style.display = "block";

          peerConnection = new RTCPeerConnection(configuration);

          stream
            .getTracks()
            .forEach((track) => peerConnection.addTrack(track, stream));

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              console.log("Sending ICE candidate:", event.candidate);
              ws.send(
                JSON.stringify({
                  type: "candidate",
                  candidate: event.candidate,
                  to: from,
                })
              );
            }
          };

          peerConnection.ontrack = (event) => {
            const remoteStream = event.streams[0];
            console.log("Remote Stream:", remoteStream);

            const remoteVideo = document.getElementById("remote-video");
            if (remoteVideo) {
              remoteVideo.srcObject = remoteStream;
              console.log("Remote video element found and stream assigned.");
            } else {
              console.error("Remote video element not found.");
            }
          };

          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(offer)
          );
          console.log("Remote Description Set with Offer:", offer);
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          console.log("Local Description Set with Answer:", answer);

          ws.send(JSON.stringify({ type: "answer", answer: answer, to: from }));

          // Process queued ICE candidates
          while (iceCandidatesQueue.length) {
            const candidate = iceCandidatesQueue.shift();
            console.log("Adding queued ICE candidate:", candidate);
            await peerConnection.addIceCandidate(
              new RTCIceCandidate(candidate)
            );
          }
        } catch (error) {
          console.error("Error handling video offer:", error);
          alert(
            "Erreur lors de l'accès aux périphériques médias : " + error.message
          );
        }
      };

      const handleVideoAnswer = async (answer) => {
        try {
          console.log("Received Answer:", answer);
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(answer)
          );
          console.log("Remote Description Set with Answer:", answer);

          // Process queued ICE candidates
          while (iceCandidatesQueue.length) {
            const candidate = iceCandidatesQueue.shift();
            console.log("Adding queued ICE candidate:", candidate);
            await peerConnection.addIceCandidate(
              new RTCIceCandidate(candidate)
            );
          }
        } catch (error) {
          console.error("Error handling video answer:", error);
        }
      };

      const handleNewICECandidate = async (candidate) => {
        try {
          console.log("New ICE candidate:", candidate);
          if (peerConnection) {
            if (peerConnection.remoteDescription) {
              await peerConnection.addIceCandidate(
                new RTCIceCandidate(candidate)
              );
              console.log("Added ICE candidate:", candidate);
            } else {
              console.log("Queuing ICE candidate:", candidate);
              iceCandidatesQueue.push(candidate);
            }
          } else {
            console.log(
              "Queuing ICE candidate (no peer connection):",
              candidate
            );
            iceCandidatesQueue.push(candidate);
          }
        } catch (error) {
          console.error("Error adding received ICE candidate", error);
        }
      };

      const inviteToVideoCall = (id) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "invite", to: id, from: userId }));
          console.log("Invitation sent to:", id);
        } else {
          console.warn("WebSocket is not open. Cannot send invitation.");
        }
      };

      const endVideoCall = () => {
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
          console.log("Peer connection closed");
          // Close camera and mic
          const localVideo = document.getElementById("local-video");
          if (localVideo.srcObject) {
            localVideo.srcObject.getTracks().forEach((track) => track.stop());
            localVideo.srcObject = null;
          }
        }
        document.getElementById("video-chat").style.display = "none";
        document.getElementById("local-video").srcObject = null;
        document.getElementById("remote-video").srcObject = null;
      };

      // Fetch user positions every 5 seconds
      setInterval(fetchUserPositions, 5000);

      // Initial fetch
      fetchUserPositions();
    </script>
  </body>
</html>
